package templates

var data = map[string]string{
	"args.gotpl":      "\t{{- range $i, $arg := . }}\n\t\tvar arg{{$i}} {{$arg.Signature }}\n\t\t{{- if eq $arg.GoType \"map[string]interface{}\" }}\n\t\t\tif tmp, ok := field.Args[{{$arg.GQLName|quote}}]; ok {\n\t\t\t\t{{- if $arg.Type.IsPtr }}\n\t\t\t\t\ttmp2 := tmp.({{$arg.GoType}})\n\t\t\t\t\targ{{$i}} = &tmp2\n\t\t\t\t{{- else }}\n\t\t\t\t\targ{{$i}} = tmp.({{$arg.GoType}})\n\t\t\t\t{{- end }}\n\t\t\t}\n\t\t{{- else}}\n\t\t\tif tmp, ok := field.Args[{{$arg.GQLName|quote}}]; ok {\n\t\t\t\tvar err error\n\t\t\t\t{{$arg.Unmarshal (print \"arg\" $i) \"tmp\" }}\n\t\t\t\tif err != nil {\n\t\t\t\t\tec.Error(err)\n\t\t\t\t\t{{- if $arg.Object.Stream }}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t{{- else }}\n\t\t\t\t\t\treturn graphql.Null\n\t\t\t\t\t{{- end }}\n\t\t\t\t}\n\t\t\t}\n\t\t{{- end}}\n\t{{- end -}}\n",
	"file.gotpl":      "// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT\n\npackage {{ .PackageName }}\n\nimport (\n{{- range $import := .Imports }}\n\t{{- $import.Write }}\n{{ end }}\n)\n\nfunc MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {\n\treturn &executableSchema{resolvers}\n}\n\ntype Resolvers interface {\n{{- range $object := .Objects -}}\n\t{{ range $field := $object.Fields -}}\n\t\t{{ $field.ResolverDeclaration }}\n\t{{ end }}\n{{- end }}\n}\n\n{{ range $model := .Models }}\n\t{{ template \"model.gotpl\" $model }}\n{{- end}}\n\ntype executableSchema struct {\n\tresolvers Resolvers\n}\n\nfunc (e *executableSchema) Schema() *schema.Schema {\n\treturn parsedSchema\n}\n\nfunc (e *executableSchema) Query(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) *graphql.Response {\n\t{{- if .QueryRoot }}\n\t\tec := executionContext{resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx}\n\n\t\tdata := ec._{{.QueryRoot.GQLType|lcFirst}}(op.Selections)\n\t\tec.wg.Wait()\n\n\t\treturn &graphql.Response{\n\t\t\tData:   data,\n\t\t\tErrors: ec.Errors,\n\t\t}\n\t{{- else }}\n\t\treturn &graphql.Response{Errors: []*errors.QueryError{ {Message: \"queries are not supported\"} }}\n\t{{- end }}\n}\n\nfunc (e *executableSchema) Mutation(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) *graphql.Response {\n\t{{- if .MutationRoot }}\n\t\tec := executionContext{resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx}\n\n\t\tdata := ec._{{.MutationRoot.GQLType|lcFirst}}(op.Selections)\n\t\tec.wg.Wait()\n\n\t\treturn &graphql.Response{\n\t\t\tData:   data,\n\t\t\tErrors: ec.Errors,\n\t\t}\n\t{{- else }}\n\t\treturn &graphql.Response{Errors: []*errors.QueryError{ {Message: \"mutations are not supported\"} }}\n\t{{- end }}\n}\n\nfunc (e *executableSchema) Subscription(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) <-chan *graphql.Response {\n\t{{- if .SubscriptionRoot }}\n\t\tevents := make(chan *graphql.Response, 10)\n\n\t\tec := executionContext{resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx}\n\n\t\teventData := ec._{{.SubscriptionRoot.GQLType|lcFirst}}(op.Selections)\n\t\tif ec.Errors != nil {\n\t\t\tevents<-&graphql.Response{\n\t\t\t\tData: graphql.Null,\n\t\t\t\tErrors: ec.Errors,\n\t\t\t}\n\t\t\tclose(events)\n\t\t} else {\n\t\t\tgo func() {\n\t\t\t\tfor data := range eventData {\n\t\t\t\t\tec.wg.Wait()\n\t\t\t\t\tevents <- &graphql.Response{\n\t\t\t\t\t\tData: data,\n\t\t\t\t\t\tErrors: ec.Errors,\n\t\t\t\t\t}\n\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\treturn events\n\t{{- else }}\n\t\tevents := make(chan *graphql.Response, 1)\n\t\tevents<-&graphql.Response{Errors: []*errors.QueryError{ {Message: \"subscriptions are not supported\"} }}\n\t\treturn events\n\t{{- end }}\n}\n\ntype executionContext struct {\n\terrors.Builder\n\tresolvers Resolvers\n\tvariables map[string]interface{}\n\tdoc       *query.Document\n\tctx       context.Context\n\twg        sync.WaitGroup\n}\n\n{{- range $object := .Objects }}\n\t{{ template \"object.gotpl\" $object }}\n{{- end}}\n\n{{- range $interface := .Interfaces }}\n\t{{ template \"interface.gotpl\" $interface }}\n{{- end }}\n\n{{- range $input := .Inputs }}\n\t{{ template \"input.gotpl\" $input }}\n{{- end }}\n\nvar parsedSchema = schema.MustParse({{.SchemaRaw|quote}})\n\nfunc (ec *executionContext) introspectSchema() *introspection.Schema {\n\treturn introspection.WrapSchema(parsedSchema)\n}\n\nfunc (ec *executionContext) introspectType(name string) *introspection.Type {\n\tt := parsedSchema.Resolve(name)\n\tif t == nil {\n\t\treturn nil\n\t}\n\treturn introspection.WrapType(t)\n}\n",
	"input.gotpl":     "\t{{- if .IsMarshaled }}\n\tfunc Unmarshal{{ .GQLType }}(v interface{}) ({{.FullName}}, error) {\n\t\tvar it {{.FullName}}\n\n\t\tfor k, v := range v.(map[string]interface{}) {\n\t\t\tswitch k {\n\t\t\t{{- range $field := .Fields }}\n\t\t\tcase {{$field.GQLName|quote}}:\n\t\t\t\tvar err error\n\t\t\t\t{{ $field.Unmarshal (print \"it.\" $field.GoVarName) \"v\" }}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn it, err\n\t\t\t\t}\n\t\t\t{{- end }}\n\t\t\t}\n\t\t}\n\n\t\treturn it, nil\n\t}\n\t{{- end }}\n",
	"interface.gotpl": "{{- $interface := . }}\n\nfunc (ec *executionContext) _{{$interface.GQLType|lcFirst}}(sel []query.Selection, it *{{$interface.FullName}}) graphql.Marshaler {\n\tswitch it := (*it).(type) {\n\tcase nil:\n\t\treturn graphql.Null\n\t{{- range $implementor := $interface.Implementors }}\n\tcase {{$implementor.FullName}}:\n\t\treturn ec._{{$implementor.GQLType|lcFirst}}(sel, &it)\n\n\tcase *{{$implementor.FullName}}:\n\t\treturn ec._{{$implementor.GQLType|lcFirst}}(sel, it)\n\n\t{{- end }}\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unexpected type %T\", it))\n\t}\n}\n",
	"model.gotpl":     "\ttype {{.GoType}} struct {\n\t\t{{- range $field := .Fields }}\n\t\t\t{{- if $field.GoVarName }}\n\t\t\t\t{{ $field.GoVarName }} {{$field.Signature}}\n\t\t\t{{- else }}\n\t\t\t\t{{ $field.GoFKName }} {{$field.GoFKType}}\n\t\t\t{{- end }}\n\t\t{{- end }}\n\t}\n",
	"object.gotpl":    "{{ $object := . }}\n\nvar {{ $object.GQLType|lcFirst}}Implementors = {{$object.Implementors}}\n\n// nolint: gocyclo, errcheck, gas, goconst\n{{- if .Stream }}\nfunc (ec *executionContext) _{{$object.GQLType|lcFirst}}(sel []query.Selection{{if not $object.Root}}, it *{{$object.FullName}}{{end}}) <-chan graphql.Marshaler {\n\tfields := graphql.CollectFields(ec.doc, sel, {{$object.GQLType|lcFirst}}Implementors, ec.variables)\n\n\tif len(fields) != 1 {\n\t\tec.Errorf(\"must subscribe to exactly one stream\")\n\t\treturn nil\n\t}\n\n\tvar field = fields[0]\n\tchannel := make(chan graphql.Marshaler, 1)\n\tswitch field.Name {\n\t{{- range $field := $object.Fields }}\n\tcase \"{{$field.GQLName}}\":\n\t\t{{- template \"args.gotpl\" $field.Args }}\n\n\t\t{{- if $field.GoVarName }}\n\t\t\tresults := it.{{$field.GoVarName}}\n\t\t{{- else if $field.GoMethodName }}\n\t\t\t{{- if $field.NoErr }}\n\t\t\t\tresults := {{$field.GoMethodName}}({{ $field.CallArgs }})\n\t\t\t{{- else }}\n\t\t\t\tresults, err := {{$field.GoMethodName}}({{ $field.CallArgs }})\n\t\t\t\tif err != nil {\n\t\t\t\t\tec.Error(err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t{{- end }}\n\t\t{{- else }}\n\t\t\tresults, err := ec.resolvers.{{ $object.GQLType }}_{{ $field.GQLName }}({{ $field.CallArgs }})\n\t\t\tif err != nil {\n\t\t\t\tec.Error(err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t{{- end }}\n\n\t\tgo func() {\n\t\t\tfor res := range results {\n\t\t\t\tvar out graphql.OrderedMap\n\t\t\t\tvar messageRes graphql.Marshaler\n\t\t\t\t{{ $field.WriteJson \"messageRes\" }}\n\t\t\t\tout.Add(field.Alias, messageRes)\n\t\t\t\tchannel <- &out\n\t\t\t}\n\t\t}()\n\n\t{{- end }}\n\tdefault:\n\t\tpanic(\"unknown field \" + strconv.Quote(field.Name))\n\t}\n\n\treturn channel\n}\n{{- else }}\nfunc (ec *executionContext) _{{$object.GQLType|lcFirst}}(sel []query.Selection{{if not $object.Root}}, it *{{$object.FullName}} {{end}}) graphql.Marshaler {\n\tfields := graphql.CollectFields(ec.doc, sel, {{$object.GQLType|lcFirst}}Implementors, ec.variables)\n\tout := graphql.NewOrderedMap(len(fields))\n\tfor i, field := range fields {\n\t\tout.Keys[i] = field.Alias\n\t\tout.Values[i] = graphql.Null\n\n\t\tswitch field.Name {\n\t\tcase \"__typename\":\n\t\t\tout.Values[i] = graphql.MarshalString({{$object.GQLType|quote}})\n\t\t{{- range $field := $object.Fields }}\n\t\tcase \"{{$field.GQLName}}\":\n\t\t\t{{- template \"args.gotpl\" $field.Args }}\n\n\t\t\t{{- if $field.IsConcurrent }}\n\t\t\t\tec.wg.Add(1)\n\t\t\t\tgo func(i int, field graphql.CollectedField) {\n\t\t\t\t\tdefer ec.wg.Done()\n\t\t\t{{- end }}\n\n\t\t\t{{- if $field.GoVarName }}\n\t\t\t\tres := it.{{$field.GoVarName}}\n\t\t\t{{- else if $field.GoMethodName }}\n\t\t\t\t{{- if $field.NoErr }}\n\t\t\t\t\tres := {{$field.GoMethodName}}({{ $field.CallArgs }})\n\t\t\t\t{{- else }}\n\t\t\t\t\tres, err := {{$field.GoMethodName}}({{ $field.CallArgs }})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tec.Error(err)\n\t\t\t\t\t\t{{ if $field.IsConcurrent }}return{{ else }}continue{{end}}\n\t\t\t\t\t}\n\t\t\t\t{{- end }}\n\t\t\t{{- else }}\n\t\t\t\tres, err := ec.resolvers.{{ $object.GQLType }}_{{ $field.GQLName }}({{ $field.CallArgs }})\n\t\t\t\tif err != nil {\n\t\t\t\t\tec.Error(err)\n\t\t\t\t\t{{ if $field.IsConcurrent }}return{{ else }}continue{{end}}\n\t\t\t\t}\n\t\t\t{{- end }}\n\n\t\t\t{{ $field.WriteJson \"out.Values[i]\" }}\n\n\t\t\t{{- if $field.IsConcurrent }}\n\t\t\t\t}(i, field)\n\t\t\t{{- end }}\n\t\t{{- end }}\n\t\tdefault:\n\t\t\tpanic(\"unknown field \" + strconv.Quote(field.Name))\n\t\t}\n\t}\n\n\treturn out\n}\n{{- end }}\n",
}
