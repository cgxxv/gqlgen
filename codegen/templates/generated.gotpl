// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package {{ .PackageName }}

import (
	%%%IMPORTS%%%

	{{ reserveImport "context"  }}
	{{ reserveImport "fmt"  }}
	{{ reserveImport "io"  }}
	{{ reserveImport "strconv"  }}
	{{ reserveImport "time"  }}
	{{ reserveImport "sync"  }}
	{{ reserveImport "errors"  }}
	{{ reserveImport "bytes"  }}

	{{ reserveImport "github.com/vektah/gqlparser" }}
	{{ reserveImport "github.com/vektah/gqlparser/ast" }}
	{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
	{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers: cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
{{- range $object := .Objects -}}
	{{ if $object.HasResolvers -}}
		{{$object.Definition.GQLDefinition.Name}}() {{$object.Definition.GQLDefinition.Name}}Resolver
	{{ end }}
{{- end }}
}

type DirectiveRoot struct {
{{ range $directive := .Directives }}
	{{ $directive.Declaration }}
{{ end }}
}

type ComplexityRoot struct {
{{ range $object := .Objects }}
	{{ if not $object.IsReserved -}}
		{{ $object.Definition.GQLDefinition.Name|toCamel }} struct {
		{{ range $field := $object.Fields -}}
			{{ if not $field.IsReserved -}}
				{{ $field.GQLName|toCamel }} {{ $field.ComplexitySignature }}
			{{ end }}
		{{- end }}
		}
	{{- end }}
{{ end }}
}

{{ range $object := .Objects -}}
	{{ if $object.HasResolvers }}
		type {{$object.Definition.GQLDefinition.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{ $field.ShortResolverDeclaration }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $object := .Objects -}}
	{{ range $field := $object.Fields -}}
		{{ if $field.Args }}
			func (e *executableSchema){{ $field.ArgsFunc }}(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
			{{ template "args.gotpl" $field.Args }}
			}
		{{ end }}
	{{ end }}
{{- end }}

{{ range $directive := .Directives }}
	{{ if $directive.Args }}
		func (e *executableSchema){{ $directive.ArgsFunc }}(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
		{{ template "args.gotpl" $directive.Args }}
		}
	{{ end }}
{{ end }}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {
	{{ range $object := .Objects }}
		{{ if not $object.IsReserved }}
			{{ range $field := $object.Fields }}
				{{ if not $field.IsReserved }}
					case "{{$object.Definition.GQLDefinition.Name}}.{{$field.GQLName}}":
						if e.complexity.{{$object.Definition.GQLDefinition.Name|toCamel}}.{{$field.GQLName|toCamel}} == nil {
							break
						}
						{{ if $field.Args }}
							args, err := e.{{ $field.ArgsFunc }}(context.TODO(),rawArgs)
							if err != nil {
								return 0, false
							}
						{{ end }}
						return e.complexity.{{$object.Definition.GQLDefinition.Name|toCamel}}.{{$field.GQLName|toCamel}}(childComplexity{{if $field.Args}}, {{$field.ComplexityArgs}} {{end}}), true
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}
	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	{{- if .QueryRoot }}
		ec := executionContext{graphql.GetRequestContext(ctx), e}

		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			data := ec._{{.QueryRoot.Definition.GQLDefinition.Name}}(ctx, op.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,		}
	{{- else }}
		return graphql.ErrorResponse(ctx, "queries are not supported")
	{{- end }}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	{{- if .MutationRoot }}
		ec := executionContext{graphql.GetRequestContext(ctx), e}

		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			data := ec._{{.MutationRoot.Definition.GQLDefinition.Name}}(ctx, op.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	{{- else }}
		return graphql.ErrorResponse(ctx, "mutations are not supported")
	{{- end }}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	{{- if .SubscriptionRoot }}
		ec := executionContext{graphql.GetRequestContext(ctx), e}

		next := ec._{{.SubscriptionRoot.Definition.GQLDefinition.Name}}(ctx, op.SelectionSet)
		if ec.Errors != nil {
			return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
		}

		var buf bytes.Buffer
		return func() *graphql.Response {
			buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
				buf.Reset()
				data := next()

				if data == nil {
					return nil
				}
				data.MarshalGQL(&buf)
				return buf.Bytes()
			})

			if buf == nil {
				return nil
			}

			return &graphql.Response{
				Data:       buf,
				Errors:     ec.Errors,
				Extensions: ec.Extensions,
			}
		}
	{{- else }}
		return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
	{{- end }}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

{{- range $object := .Objects }}
	{{ template "object.gotpl" $object }}

	{{- range $field := $object.Fields }}
		{{ template "field.gotpl" $field }}
	{{ end }}
{{- end}}

{{- range $interface := .Interfaces }}
	{{ template "interface.gotpl" $interface }}
{{- end }}

{{- range $input := .Inputs }}
	{{ template "input.gotpl" $input }}
{{- end }}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	{{- if .Directives }}
	rctx := graphql.GetResolverContext(ctx)
	for _, d := range rctx.Field.Definition.Directives {
		switch d.Name {
		{{- range $directive := .Directives }}
		case "{{$directive.Name}}":
			if ec.directives.{{$directive.Name|ucFirst}} != nil {
				{{- if $directive.Args }}
					rawArgs := d.ArgumentMap(ec.Variables)
					args, err := ec.{{ $directive.ArgsFunc }}(ctx,rawArgs)
					if err != nil {
						ec.Error(ctx, err)
						return nil
					}
				{{- end }}
				n := next
				next = func(ctx context.Context) (interface{}, error) {
					return ec.directives.{{$directive.Name|ucFirst}}({{$directive.CallArgs}})
				}
			}
		{{- end }}
		}
	}
	{{- end }}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	{{- range $filename, $schema := .SchemaStr }}
		&ast.Source{Name: {{$filename|quote}}, Input: {{$schema|rawQuote}}},
	{{- end }}
)



// ChainFieldMiddleware add chain by FieldMiddleware
// nolint: deadcode
func chainFieldMiddleware(handleFunc ...graphql.FieldMiddleware) graphql.FieldMiddleware {
	n := len(handleFunc)

	if n > 1 {
		lastI := n - 1
		return func(ctx context.Context, next graphql.Resolver) (interface{}, error) {
			var (
				chainHandler graphql.Resolver
				curI         int
			)
			chainHandler = func(currentCtx context.Context) (interface{}, error) {
				if curI == lastI {
					return next(currentCtx)
				}
				curI++
				res, err := handleFunc[curI](currentCtx, chainHandler)
				curI--
				return res, err

			}
			return handleFunc[0](ctx, chainHandler)
		}
	}

	if n == 1 {
		return handleFunc[0]
	}

	return func(ctx context.Context, next graphql.Resolver) (interface{}, error) {
		return next(ctx)
	}
}
