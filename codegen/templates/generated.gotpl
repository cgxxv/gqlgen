// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package {{ .PackageName }}

import (
{{- range $import := .Imports }}
	{{- $import.Write }}
{{ end }}
)

func MakeExecutableSchema(resolvers Resolvers, opts ...ExecutableOption) graphql.ExecutableSchema {
	ret := &executableSchema{resolvers: resolvers}
	for _, opt := range opts {
		opt(ret)
	}
	return ret
}

type Resolvers interface {
{{- range $object := .Objects -}}
	{{ range $field := $object.Fields -}}
		{{ $field.ResolverDeclaration }}
	{{ end }}
{{- end }}
}

type ExecutableOption func(*executableSchema)

func WithErrorConverter(fn func(error) string) ExecutableOption {
	return func(s *executableSchema) {
		s.errorMessageFn = fn
	}
}

type executableSchema struct {
	resolvers      Resolvers
	errorMessageFn func(error) string
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) *graphql.Response {
	{{- if .QueryRoot }}
		ec := e.makeExecutionContext(ctx, doc, variables, recover)

		data := ec._{{.QueryRoot.GQLType}}(op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)

		return &graphql.Response{
			Data:   buf.Bytes(),
			Errors: ec.Errors,
		}
	{{- else }}
		return &graphql.Response{Errors: []*errors.QueryError{ {Message: "queries are not supported"} }}
	{{- end }}
}

func (e *executableSchema) Mutation(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) *graphql.Response {
	{{- if .MutationRoot }}
		ec := e.makeExecutionContext(ctx, doc, variables, recover)

		data := ec._{{.MutationRoot.GQLType}}(op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)

		return &graphql.Response{
			Data:   buf.Bytes(),
			Errors: ec.Errors,
		}
	{{- else }}
		return &graphql.Response{Errors: []*errors.QueryError{ {Message: "mutations are not supported"} }}
	{{- end }}
}

func (e *executableSchema) Subscription(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) func() *graphql.Response {
	{{- if .SubscriptionRoot }}
		ec := e.makeExecutionContext(ctx, doc, variables, recover)

		next := ec._{{.SubscriptionRoot.GQLType}}(op.Selections)
		if ec.Errors != nil {
			return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
		}

		var buf bytes.Buffer
		return func() *graphql.Response {
			buf.Reset()
			data := next()
			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			errs := ec.Errors
			ec.Errors = nil
			return &graphql.Response{
				Data:   buf.Bytes(),
				Errors: errs,
			}
		}
	{{- else }}
		return graphql.OneShot(&graphql.Response{Errors: []*errors.QueryError{ {Message: "subscriptions are not supported"} }})
	{{- end }}
}

func (e *executableSchema) makeExecutionContext(ctx context.Context, doc *query.Document, variables map[string]interface{}, recover graphql.RecoverFunc) *executionContext {
	errBuilder := errors.Builder{ErrorMessageFn: e.errorMessageFn}
	return &executionContext{
		Builder: errBuilder, resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx, recover: recover,
	}
}

type executionContext struct {
	errors.Builder
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
	recover   graphql.RecoverFunc
}

{{- range $object := .Objects }}
	{{ template "object.gotpl" $object }}

	{{- range $field := $object.Fields }}
		{{ template "field.gotpl" $field }}
	{{ end }}
{{- end}}

{{- range $interface := .Interfaces }}
	{{ template "interface.gotpl" $interface }}
{{- end }}

{{- range $input := .Inputs }}
	{{ template "input.gotpl" $input }}
{{- end }}

var parsedSchema = schema.MustParse({{.SchemaRaw|quote}})

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}
