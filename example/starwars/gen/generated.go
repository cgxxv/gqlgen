// This file was generated by github.com/vektah/graphql-go, DO NOT EDIT

package gen

import (
	context "context"
	fmt "fmt"
	io "io"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"

	mapstructure "github.com/mitchellh/mapstructure"
	errors "github.com/vektah/graphql-go/errors"
	starwars "github.com/vektah/graphql-go/example/starwars"
	introspection "github.com/vektah/graphql-go/introspection"
	jsonw "github.com/vektah/graphql-go/jsonw"
	query "github.com/vektah/graphql-go/query"
	relay "github.com/vektah/graphql-go/relay"
	schema "github.com/vektah/graphql-go/schema"
	validation "github.com/vektah/graphql-go/validation"
)

type Resolvers interface {
	Droid_friends(ctx context.Context, it *starwars.Droid) ([]starwars.Character, error)
	Droid_friendsConnection(ctx context.Context, it *starwars.Droid, first *int, after *string) (starwars.FriendsConnection, error)

	Human_friends(ctx context.Context, it *starwars.Human) ([]starwars.Character, error)
	Human_friendsConnection(ctx context.Context, it *starwars.Human, first *int, after *string) (starwars.FriendsConnection, error)

	Human_starships(ctx context.Context, it *starwars.Human) ([]starwars.Starship, error)

	Mutation_createReview(ctx context.Context, episode string, review starwars.Review) (*starwars.Review, error)

	Query_hero(ctx context.Context, episode *string) (starwars.Character, error)
	Query_reviews(ctx context.Context, episode string, since *time.Time) ([]starwars.Review, error)
	Query_search(ctx context.Context, text string) ([]starwars.SearchResult, error)
	Query_character(ctx context.Context, id string) (starwars.Character, error)
	Query_droid(ctx context.Context, id string) (*starwars.Droid, error)
	Query_human(ctx context.Context, id string) (*starwars.Human, error)
	Query_starship(ctx context.Context, id string) (*starwars.Starship, error)
}

func NewResolver(resolvers Resolvers) relay.Resolver {
	return func(ctx context.Context, document string, operationName string, variables map[string]interface{}, w io.Writer) []*errors.QueryError {
		doc, qErr := query.Parse(document)
		if qErr != nil {
			return []*errors.QueryError{qErr}
		}

		errs := validation.Validate(parsedSchema, doc)
		if len(errs) != 0 {
			return errs
		}

		op, err := doc.GetOperation(operationName)
		if err != nil {
			return []*errors.QueryError{errors.Errorf("%s", err)}
		}

		if op.Type != query.Query && op.Type != query.Mutation {
			return []*errors.QueryError{errors.Errorf("unsupported operation type")}
		}

		c := executionContext{
			resolvers: resolvers,
			variables: variables,
			doc:       doc,
			ctx:       ctx,
			json:      jsonw.New(w),
		}

		// TODO: parallelize if query.

		c.json.BeginObject()

		c.json.ObjectKey("data")

		if op.Type == query.Query {
			c._query(op.Selections, nil)
		} else if op.Type == query.Mutation {
			c._mutation(op.Selections, nil)
		} else {
			c.Errorf("unsupported operation %s", op.Type)
			c.json.Null()
		}

		if len(c.Errors) > 0 {
			c.json.ObjectKey("errors")
			errors.WriteErrors(w, c.Errors)
		}

		c.json.EndObject()
		return nil
	}
}

type executionContext struct {
	errors.Builder
	json      *jsonw.Writer
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
}

var (
	droidImplementors             = []string{"Droid", "Character"}
	friendsConnectionImplementors = []string{"FriendsConnection"}
	friendsEdgeImplementors       = []string{"FriendsEdge"}
	humanImplementors             = []string{"Human", "Character"}
	mutationImplementors          = []string{"Mutation"}
	pageInfoImplementors          = []string{"PageInfo"}
	queryImplementors             = []string{"Query"}
	reviewImplementors            = []string{"Review"}
	starshipImplementors          = []string{"Starship"}
	__DirectiveImplementors       = []string{"__Directive"}
	__EnumValueImplementors       = []string{"__EnumValue"}
	__FieldImplementors           = []string{"__Field"}
	__InputValueImplementors      = []string{"__InputValue"}
	__SchemaImplementors          = []string{"__Schema"}
	__TypeImplementors            = []string{"__Type"}
)

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _droid(sel []query.Selection, it *starwars.Droid) {
	groupedFieldSet := ec.collectFields(sel, droidImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "id":
			ec.json.ObjectKey(field.Alias)
			res := it.ID
			ec.json.String(res)

		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name
			ec.json.String(res)

		case "friends":
			ec.json.ObjectKey(field.Alias)
			res, err := ec.resolvers.Droid_friends(ec.ctx, it)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._character(field.Selections, val)
			}
			ec.json.EndArray()

		case "friendsConnection":
			ec.json.ObjectKey(field.Alias)
			var arg0 *int
			if tmp, ok := field.Args["first"]; ok {
				tmp2, err := coerceInt(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = &tmp2
			}
			var arg1 *string
			if tmp, ok := field.Args["after"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg1 = &tmp2
			}
			res, err := ec.resolvers.Droid_friendsConnection(ec.ctx, it, arg0, arg1)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec._friendsConnection(field.Selections, &res)

		case "appearsIn":
			ec.json.ObjectKey(field.Alias)
			res := it.AppearsIn
			ec.json.BeginArray()
			for _, val := range res {
				ec.json.String(val)
			}
			ec.json.EndArray()

		case "primaryFunction":
			ec.json.ObjectKey(field.Alias)
			res := it.PrimaryFunction
			ec.json.String(res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _friendsConnection(sel []query.Selection, it *starwars.FriendsConnection) {
	groupedFieldSet := ec.collectFields(sel, friendsConnectionImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "totalCount":
			ec.json.ObjectKey(field.Alias)
			res := it.TotalCount()
			ec.json.Int(res)

		case "edges":
			ec.json.ObjectKey(field.Alias)
			res, err := it.Edges()
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._friendsEdge(field.Selections, &val)
			}
			ec.json.EndArray()

		case "friends":
			ec.json.ObjectKey(field.Alias)
			res, err := it.Friends()
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._character(field.Selections, val)
			}
			ec.json.EndArray()

		case "pageInfo":
			ec.json.ObjectKey(field.Alias)
			res := it.PageInfo()
			ec._pageInfo(field.Selections, &res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _friendsEdge(sel []query.Selection, it *starwars.FriendsEdge) {
	groupedFieldSet := ec.collectFields(sel, friendsEdgeImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "cursor":
			ec.json.ObjectKey(field.Alias)
			res := it.Cursor
			ec.json.String(res)

		case "node":
			ec.json.ObjectKey(field.Alias)
			res := it.Node
			ec._character(field.Selections, res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _human(sel []query.Selection, it *starwars.Human) {
	groupedFieldSet := ec.collectFields(sel, humanImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "id":
			ec.json.ObjectKey(field.Alias)
			res := it.ID
			ec.json.String(res)

		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name
			ec.json.String(res)

		case "height":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["unit"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res := it.Height(arg0)
			ec.json.Float64(res)

		case "mass":
			ec.json.ObjectKey(field.Alias)
			res := it.Mass
			ec.json.Float64(res)

		case "friends":
			ec.json.ObjectKey(field.Alias)
			res, err := ec.resolvers.Human_friends(ec.ctx, it)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._character(field.Selections, val)
			}
			ec.json.EndArray()

		case "friendsConnection":
			ec.json.ObjectKey(field.Alias)
			var arg0 *int
			if tmp, ok := field.Args["first"]; ok {
				tmp2, err := coerceInt(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = &tmp2
			}
			var arg1 *string
			if tmp, ok := field.Args["after"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg1 = &tmp2
			}
			res, err := ec.resolvers.Human_friendsConnection(ec.ctx, it, arg0, arg1)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec._friendsConnection(field.Selections, &res)

		case "appearsIn":
			ec.json.ObjectKey(field.Alias)
			res := it.AppearsIn
			ec.json.BeginArray()
			for _, val := range res {
				ec.json.String(val)
			}
			ec.json.EndArray()

		case "starships":
			ec.json.ObjectKey(field.Alias)
			res, err := ec.resolvers.Human_starships(ec.ctx, it)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._starship(field.Selections, &val)
			}
			ec.json.EndArray()

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _mutation(sel []query.Selection, it *interface{}) {
	groupedFieldSet := ec.collectFields(sel, mutationImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "createReview":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["episode"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			var arg1 starwars.Review
			err := unpackComplexArg(&arg1, field.Args["review"])
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			res, err := ec.resolvers.Mutation_createReview(ec.ctx, arg0, arg1)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			if res == nil {
				ec.json.Null()
			} else {
				ec._review(field.Selections, res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _pageInfo(sel []query.Selection, it *starwars.PageInfo) {
	groupedFieldSet := ec.collectFields(sel, pageInfoImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "startCursor":
			ec.json.ObjectKey(field.Alias)
			res := it.StartCursor
			ec.json.String(res)

		case "endCursor":
			ec.json.ObjectKey(field.Alias)
			res := it.EndCursor
			ec.json.String(res)

		case "hasNextPage":
			ec.json.ObjectKey(field.Alias)
			res := it.HasNextPage
			ec.json.Bool(res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _query(sel []query.Selection, it *interface{}) {
	groupedFieldSet := ec.collectFields(sel, queryImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "hero":
			ec.json.ObjectKey(field.Alias)
			var arg0 *string
			if tmp, ok := field.Args["episode"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = &tmp2
			}
			res, err := ec.resolvers.Query_hero(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec._character(field.Selections, res)

		case "reviews":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["episode"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			var arg1 *time.Time
			if tmp, ok := field.Args["since"]; ok {
				if tmpStr, ok := tmp.(string); ok {
					tmpDate, err := time.Parse(time.RFC3339, tmpStr)
					if err != nil {
						ec.Error(err)
						ec.json.Null()
						continue
					}
					arg1 = &tmpDate
				} else {
					ec.Errorf("Time 'since' should be RFC3339 formatted string")
					ec.json.Null()
					continue
				}
			}
			res, err := ec.resolvers.Query_reviews(ec.ctx, arg0, arg1)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._review(field.Selections, &val)
			}
			ec.json.EndArray()

		case "search":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["text"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res, err := ec.resolvers.Query_search(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec.json.BeginArray()
			for _, val := range res {
				ec._searchResult(field.Selections, val)
			}
			ec.json.EndArray()

		case "character":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["id"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res, err := ec.resolvers.Query_character(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			ec._character(field.Selections, res)

		case "droid":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["id"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res, err := ec.resolvers.Query_droid(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			if res == nil {
				ec.json.Null()
			} else {
				ec._droid(field.Selections, res)
			}

		case "human":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["id"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res, err := ec.resolvers.Query_human(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			if res == nil {
				ec.json.Null()
			} else {
				ec._human(field.Selections, res)
			}

		case "starship":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["id"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res, err := ec.resolvers.Query_starship(ec.ctx, arg0)
			if err != nil {
				ec.Error(err)
				ec.json.Null()
				continue
			}
			if res == nil {
				ec.json.Null()
			} else {
				ec._starship(field.Selections, res)
			}

		case "__schema":
			ec.json.ObjectKey(field.Alias)
			res := ec.introspectSchema()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Schema(field.Selections, res)
			}

		case "__type":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["name"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res := ec.introspectType(arg0)
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _review(sel []query.Selection, it *starwars.Review) {
	groupedFieldSet := ec.collectFields(sel, reviewImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "stars":
			ec.json.ObjectKey(field.Alias)
			res := it.Stars
			ec.json.Int(res)

		case "commentary":
			ec.json.ObjectKey(field.Alias)
			res := it.Commentary
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "time":
			ec.json.ObjectKey(field.Alias)
			res := it.Time
			ec.json.Time(res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _starship(sel []query.Selection, it *starwars.Starship) {
	groupedFieldSet := ec.collectFields(sel, starshipImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "id":
			ec.json.ObjectKey(field.Alias)
			res := it.ID
			ec.json.String(res)

		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name
			ec.json.String(res)

		case "length":
			ec.json.ObjectKey(field.Alias)
			var arg0 string
			if tmp, ok := field.Args["unit"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res := it.Length(arg0)
			ec.json.Float64(res)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(sel []query.Selection, it *introspection.Directive) {
	groupedFieldSet := ec.collectFields(sel, __DirectiveImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name()
			ec.json.String(res)

		case "description":
			ec.json.ObjectKey(field.Alias)
			res := it.Description()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "locations":
			ec.json.ObjectKey(field.Alias)
			res := it.Locations()
			ec.json.BeginArray()
			for _, val := range res {
				ec.json.String(val)
			}
			ec.json.EndArray()

		case "args":
			ec.json.ObjectKey(field.Alias)
			res := it.Args()
			ec.json.BeginArray()
			for _, val := range res {
				if val == nil {
					ec.json.Null()
				} else {
					ec.___InputValue(field.Selections, val)
				}
			}
			ec.json.EndArray()

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(sel []query.Selection, it *introspection.EnumValue) {
	groupedFieldSet := ec.collectFields(sel, __EnumValueImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name()
			ec.json.String(res)

		case "description":
			ec.json.ObjectKey(field.Alias)
			res := it.Description()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "isDeprecated":
			ec.json.ObjectKey(field.Alias)
			res := it.IsDeprecated()
			ec.json.Bool(res)

		case "deprecationReason":
			ec.json.ObjectKey(field.Alias)
			res := it.DeprecationReason()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(sel []query.Selection, it *introspection.Field) {
	groupedFieldSet := ec.collectFields(sel, __FieldImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name()
			ec.json.String(res)

		case "description":
			ec.json.ObjectKey(field.Alias)
			res := it.Description()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "args":
			ec.json.ObjectKey(field.Alias)
			res := it.Args()
			ec.json.BeginArray()
			for _, val := range res {
				if val == nil {
					ec.json.Null()
				} else {
					ec.___InputValue(field.Selections, val)
				}
			}
			ec.json.EndArray()

		case "type":
			ec.json.ObjectKey(field.Alias)
			res := it.Type()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		case "isDeprecated":
			ec.json.ObjectKey(field.Alias)
			res := it.IsDeprecated()
			ec.json.Bool(res)

		case "deprecationReason":
			ec.json.ObjectKey(field.Alias)
			res := it.DeprecationReason()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(sel []query.Selection, it *introspection.InputValue) {
	groupedFieldSet := ec.collectFields(sel, __InputValueImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name()
			ec.json.String(res)

		case "description":
			ec.json.ObjectKey(field.Alias)
			res := it.Description()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "type":
			ec.json.ObjectKey(field.Alias)
			res := it.Type()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		case "defaultValue":
			ec.json.ObjectKey(field.Alias)
			res := it.DefaultValue()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(sel []query.Selection, it *introspection.Schema) {
	groupedFieldSet := ec.collectFields(sel, __SchemaImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "types":
			ec.json.ObjectKey(field.Alias)
			res := it.Types()
			ec.json.BeginArray()
			for _, val := range res {
				if val == nil {
					ec.json.Null()
				} else {
					ec.___Type(field.Selections, val)
				}
			}
			ec.json.EndArray()

		case "queryType":
			ec.json.ObjectKey(field.Alias)
			res := it.QueryType()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		case "mutationType":
			ec.json.ObjectKey(field.Alias)
			res := it.MutationType()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		case "subscriptionType":
			ec.json.ObjectKey(field.Alias)
			res := it.SubscriptionType()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		case "directives":
			ec.json.ObjectKey(field.Alias)
			res := it.Directives()
			ec.json.BeginArray()
			for _, val := range res {
				if val == nil {
					ec.json.Null()
				} else {
					ec.___Directive(field.Selections, val)
				}
			}
			ec.json.EndArray()

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(sel []query.Selection, it *introspection.Type) {
	groupedFieldSet := ec.collectFields(sel, __TypeImplementors, map[string]bool{})
	ec.json.BeginObject()
	for _, field := range groupedFieldSet {
		switch field.Name {
		case "kind":
			ec.json.ObjectKey(field.Alias)
			res := it.Kind()
			ec.json.String(res)

		case "name":
			ec.json.ObjectKey(field.Alias)
			res := it.Name()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "description":
			ec.json.ObjectKey(field.Alias)
			res := it.Description()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.String(*res)
			}

		case "fields":
			ec.json.ObjectKey(field.Alias)
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				tmp2, err := coerceBool(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res := it.Fields(arg0)
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.BeginArray()
				for _, val := range *res {
					if val == nil {
						ec.json.Null()
					} else {
						ec.___Field(field.Selections, val)
					}
				}
				ec.json.EndArray()
			}

		case "interfaces":
			ec.json.ObjectKey(field.Alias)
			res := it.Interfaces()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.BeginArray()
				for _, val := range *res {
					if val == nil {
						ec.json.Null()
					} else {
						ec.___Type(field.Selections, val)
					}
				}
				ec.json.EndArray()
			}

		case "possibleTypes":
			ec.json.ObjectKey(field.Alias)
			res := it.PossibleTypes()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.BeginArray()
				for _, val := range *res {
					if val == nil {
						ec.json.Null()
					} else {
						ec.___Type(field.Selections, val)
					}
				}
				ec.json.EndArray()
			}

		case "enumValues":
			ec.json.ObjectKey(field.Alias)
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				tmp2, err := coerceBool(tmp)
				if err != nil {
					ec.Error(err)
					ec.json.Null()
					continue
				}
				arg0 = tmp2
			}
			res := it.EnumValues(arg0)
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.BeginArray()
				for _, val := range *res {
					if val == nil {
						ec.json.Null()
					} else {
						ec.___EnumValue(field.Selections, val)
					}
				}
				ec.json.EndArray()
			}

		case "inputFields":
			ec.json.ObjectKey(field.Alias)
			res := it.InputFields()
			if res == nil {
				ec.json.Null()
			} else {
				ec.json.BeginArray()
				for _, val := range *res {
					if val == nil {
						ec.json.Null()
					} else {
						ec.___InputValue(field.Selections, val)
					}
				}
				ec.json.EndArray()
			}

		case "ofType":
			ec.json.ObjectKey(field.Alias)
			res := it.OfType()
			if res == nil {
				ec.json.Null()
			} else {
				ec.___Type(field.Selections, res)
			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	ec.json.EndObject()
}

func (ec *executionContext) _character(sel []query.Selection, it starwars.Character) {
	switch it := it.(type) {
	case nil:
		ec.json.Null()

	case starwars.Human:
		ec._human(sel, &it)

	case *starwars.Human:
		ec._human(sel, it)

	case starwars.Droid:
		ec._droid(sel, &it)

	case *starwars.Droid:
		ec._droid(sel, it)

	default:
		panic(fmt.Errorf("unexpected type %T", it))
	}
}

func (ec *executionContext) _searchResult(sel []query.Selection, it starwars.SearchResult) {
	switch it := it.(type) {
	case nil:
		ec.json.Null()

	case starwars.Human:
		ec._human(sel, &it)

	case *starwars.Human:
		ec._human(sel, it)

	case starwars.Droid:
		ec._droid(sel, &it)

	case *starwars.Droid:
		ec._droid(sel, it)

	case starwars.Starship:
		ec._starship(sel, &it)

	case *starwars.Starship:
		ec._starship(sel, it)

	default:
		panic(fmt.Errorf("unexpected type %T", it))
	}
}

var parsedSchema = schema.MustParse("schema {\n    query: Query\n    mutation: Mutation\n}\n# The query type, represents all of the entry points into our object graph\ntype Query {\n    hero(episode: Episode = NEWHOPE): Character\n    reviews(episode: Episode!, since: Time): [Review]!\n    search(text: String!): [SearchResult]!\n    character(id: ID!): Character\n    droid(id: ID!): Droid\n    human(id: ID!): Human\n    starship(id: ID!): Starship\n}\n# The mutation type, represents all updates we can make to our data\ntype Mutation {\n    createReview(episode: Episode!, review: ReviewInput!): Review\n}\n# The episodes in the Star Wars trilogy\nenum Episode {\n    # Star Wars Episode IV: A New Hope, released in 1977.\n    NEWHOPE\n    # Star Wars Episode V: The Empire Strikes Back, released in 1980.\n    EMPIRE\n    # Star Wars Episode VI: Return of the Jedi, released in 1983.\n    JEDI\n}\n# A character from the Star Wars universe\ninterface Character {\n    # The ID of the character\n    id: ID!\n    # The name of the character\n    name: String!\n    # The friends of the character, or an empty list if they have none\n    friends: [Character]\n    # The friends of the character exposed as a connection with edges\n    friendsConnection(first: Int, after: ID): FriendsConnection!\n    # The movies this character appears in\n    appearsIn: [Episode!]!\n}\n# Units of height\nenum LengthUnit {\n    # The standard unit around the world\n    METER\n    # Primarily used in the United States\n    FOOT\n}\n# A humanoid creature from the Star Wars universe\ntype Human implements Character {\n    # The ID of the human\n    id: ID!\n    # What this human calls themselves\n    name: String!\n    # Height in the preferred unit, default is meters\n    height(unit: LengthUnit = METER): Float!\n    # Mass in kilograms, or null if unknown\n    mass: Float\n    # This human's friends, or an empty list if they have none\n    friends: [Character]\n    # The friends of the human exposed as a connection with edges\n    friendsConnection(first: Int, after: ID): FriendsConnection!\n    # The movies this human appears in\n    appearsIn: [Episode!]!\n    # A list of starships this person has piloted, or an empty list if none\n    starships: [Starship]\n}\n# An autonomous mechanical character in the Star Wars universe\ntype Droid implements Character {\n    # The ID of the droid\n    id: ID!\n    # What others call this droid\n    name: String!\n    # This droid's friends, or an empty list if they have none\n    friends: [Character]\n    # The friends of the droid exposed as a connection with edges\n    friendsConnection(first: Int, after: ID): FriendsConnection!\n    # The movies this droid appears in\n    appearsIn: [Episode!]!\n    # This droid's primary function\n    primaryFunction: String\n}\n# A connection object for a character's friends\ntype FriendsConnection {\n    # The total number of friends\n    totalCount: Int!\n    # The edges for each of the character's friends.\n    edges: [FriendsEdge]\n    # A list of the friends, as a convenience when edges are not needed.\n    friends: [Character]\n    # Information for paginating this connection\n    pageInfo: PageInfo!\n}\n# An edge object for a character's friends\ntype FriendsEdge {\n    # A cursor used for pagination\n    cursor: ID!\n    # The character represented by this friendship edge\n    node: Character\n}\n# Information for paginating this connection\ntype PageInfo {\n    startCursor: ID\n    endCursor: ID\n    hasNextPage: Boolean!\n}\n# Represents a review for a movie\ntype Review {\n    # The number of stars this review gave, 1-5\n    stars: Int!\n    # Comment about the movie\n    commentary: String\n    # when the review was posted\n    time: Time\n}\n# The input object sent when someone is creating a new review\ninput ReviewInput {\n    # 0-5 stars\n    stars: Int!\n    # Comment about the movie, optional\n    commentary: String\n    # when the review was posted\n    time: Time\n}\ntype Starship {\n    # The ID of the starship\n    id: ID!\n    # The name of the starship\n    name: String!\n    # Length of the starship, along the longest axis\n    length(unit: LengthUnit = METER): Float!\n}\nunion SearchResult = Human | Droid | Starship\n")

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

func instanceOf(val string, satisfies []string) bool {
	for _, s := range satisfies {
		if val == s {
			return true
		}
	}
	return false
}

func (ec *executionContext) collectFields(selSet []query.Selection, satisfies []string, visited map[string]bool) []collectedField {
	var groupedFields []collectedField

	for _, sel := range selSet {
		switch sel := sel.(type) {
		case *query.Field:
			f := getOrCreateField(&groupedFields, sel.Name.Name, func() collectedField {
				f := collectedField{
					Alias: sel.Alias.Name,
					Name:  sel.Name.Name,
				}
				if len(sel.Arguments) > 0 {
					f.Args = map[string]interface{}{}
					for _, arg := range sel.Arguments {
						f.Args[arg.Name.Name] = arg.Value.Value(ec.variables)
					}
				}
				return f
			})

			f.Selections = append(f.Selections, sel.Selections...)
		case *query.InlineFragment:
			if !instanceOf(sel.On.Ident.Name, satisfies) {
				continue
			}

			for _, childField := range ec.collectFields(sel.Selections, satisfies, visited) {
				f := getOrCreateField(&groupedFields, childField.Name, func() collectedField { return childField })
				f.Selections = append(f.Selections, childField.Selections...)
			}

		case *query.FragmentSpread:
			fragmentName := sel.Name.Name
			if _, seen := visited[fragmentName]; seen {
				continue
			}
			visited[fragmentName] = true

			fragment := ec.doc.Fragments.Get(fragmentName)
			if fragment == nil {
				ec.Errorf("missing fragment %s", fragmentName)
				continue
			}

			if !instanceOf(fragment.On.Ident.Name, satisfies) {
				continue
			}

			for _, childField := range ec.collectFields(fragment.Selections, satisfies, visited) {
				f := getOrCreateField(&groupedFields, childField.Name, func() collectedField { return childField })
				f.Selections = append(f.Selections, childField.Selections...)
			}

		default:
			panic(fmt.Errorf("unsupported %T", sel))
		}
	}

	return groupedFields
}

type collectedField struct {
	Alias      string
	Name       string
	Args       map[string]interface{}
	Selections []query.Selection
}

func decodeHook(sourceType reflect.Type, destType reflect.Type, value interface{}) (interface{}, error) {
	if destType.PkgPath() == "time" && destType.Name() == "Time" {
		if dateStr, ok := value.(string); ok {
			return time.Parse(time.RFC3339, dateStr)
		}
		return nil, errors.Errorf("time should be an RFC3339 formatted string")
	}
	return value, nil
}

// nolint: deadcode, megacheck
func unpackComplexArg(result interface{}, data interface{}) error {
	decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		TagName:     "graphql",
		ErrorUnused: true,
		Result:      result,
		DecodeHook:  decodeHook,
	})
	if err != nil {
		panic(err)
	}

	return decoder.Decode(data)
}

func getOrCreateField(c *[]collectedField, name string, creator func() collectedField) *collectedField {
	for i, cf := range *c {
		if cf.Alias == name {
			return &(*c)[i]
		}
	}

	f := creator()

	*c = append(*c, f)
	return &(*c)[len(*c)-1]
}

// nolint: deadcode, megacheck
func coerceString(v interface{}) (string, error) {
	switch v := v.(type) {
	case string:
		return v, nil
	case int:
		return strconv.Itoa(v), nil
	case float64:
		return fmt.Sprintf("%f", v), nil
	case bool:
		if v {
			return "true", nil
		} else {
			return "false", nil
		}
	case nil:
		return "null", nil
	default:
		return "", fmt.Errorf("%T is not a string", v)
	}
}

// nolint: deadcode, megacheck
func coerceBool(v interface{}) (bool, error) {
	switch v := v.(type) {
	case string:
		return "true" == strings.ToLower(v), nil
	case int:
		return v != 0, nil
	case bool:
		return v, nil
	default:
		return false, fmt.Errorf("%T is not a bool", v)
	}
}

// nolint: deadcode, megacheck
func coerceInt(v interface{}) (int, error) {
	switch v := v.(type) {
	case string:
		return strconv.Atoi(v)
	case int:
		return v, nil
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("%T is not an int", v)
	}
}

// nolint: deadcode, megacheck
func coercefloat64(v interface{}) (float64, error) {
	switch v := v.(type) {
	case string:
		return strconv.ParseFloat(v, 64)
	case int:
		return float64(v), nil
	case float64:
		return v, nil
	default:
		return 0, fmt.Errorf("%T is not an float", v)
	}
}
