// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package dataloader

import (
	context "context"
	strconv "strconv"
	sync "sync"
	time "time"

	graphql "github.com/vektah/gqlgen/graphql"
	errors "github.com/vektah/gqlgen/neelance/errors"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers}
}

type Resolvers interface {
	Customer_address(ctx context.Context, it *Customer) (*Address, error)
	Customer_orders(ctx context.Context, it *Customer) ([]Order, error)

	Order_items(ctx context.Context, it *Order) ([]Item, error)
	Query_customers(ctx context.Context) ([]Customer, error)
	Query_torture(ctx context.Context, customerIds [][]int) ([][]Customer, error)
}

type Address struct {
	ID      int
	Street  string
	Country string
}

type Customer struct {
	ID        int
	Name      string
	AddressID int
	OrdersID  int
}

type Item struct {
	Name string
}

type Order struct {
	ID      int
	Date    time.Time
	Amount  float64
	ItemsID int
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) *graphql.Response {
	ec := executionContext{resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx}

	data := ec._query(op.Selections)
	ec.wg.Wait()

	return &graphql.Response{
		Data:   data,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) *graphql.Response {
	return &graphql.Response{Errors: []*errors.QueryError{{Message: "mutations are not supported"}}}
}

func (e *executableSchema) Subscription(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation) <-chan *graphql.Response {
	events := make(chan *graphql.Response, 1)
	events <- &graphql.Response{Errors: []*errors.QueryError{{Message: "subscriptions are not supported"}}}
	return events
}

type executionContext struct {
	errors.Builder
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
	wg        sync.WaitGroup
}

var addressImplementors = []string{"Address"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _address(sel []query.Selection, it *Address) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, addressImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Address")
		case "id":
			res := it.ID

			out.Values[i] = graphql.MarshalInt(res)
		case "street":
			res := it.Street

			out.Values[i] = graphql.MarshalString(res)
		case "country":
			res := it.Country

			out.Values[i] = graphql.MarshalString(res)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var customerImplementors = []string{"Customer"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _customer(sel []query.Selection, it *Customer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, customerImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Customer")
		case "id":
			res := it.ID

			out.Values[i] = graphql.MarshalInt(res)
		case "name":
			res := it.Name

			out.Values[i] = graphql.MarshalString(res)
		case "address":
			ec.wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				defer ec.wg.Done()
				res, err := ec.resolvers.Customer_address(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				if res == nil {
					out.Values[i] = graphql.Null
				} else {
					out.Values[i] = ec._address(field.Selections, res)
				}
			}(i, field)
		case "orders":
			ec.wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				defer ec.wg.Done()
				res, err := ec.resolvers.Customer_orders(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				arr1 := graphql.Array{}
				for idx1 := range res {
					var tmp1 graphql.Marshaler
					tmp1 = ec._order(field.Selections, &res[idx1])
					arr1 = append(arr1, tmp1)
				}
				out.Values[i] = arr1
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var itemImplementors = []string{"Item"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _item(sel []query.Selection, it *Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, itemImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "name":
			res := it.Name

			out.Values[i] = graphql.MarshalString(res)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var orderImplementors = []string{"Order"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _order(sel []query.Selection, it *Order) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, orderImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Order")
		case "id":
			res := it.ID

			out.Values[i] = graphql.MarshalInt(res)
		case "date":
			res := it.Date

			out.Values[i] = graphql.MarshalTime(res)
		case "amount":
			res := it.Amount

			out.Values[i] = graphql.MarshalFloat(res)
		case "items":
			ec.wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				defer ec.wg.Done()
				res, err := ec.resolvers.Order_items(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				arr1 := graphql.Array{}
				for idx1 := range res {
					var tmp1 graphql.Marshaler
					tmp1 = ec._item(field.Selections, &res[idx1])
					arr1 = append(arr1, tmp1)
				}
				out.Values[i] = arr1
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _query(sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, queryImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "customers":
			ec.wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				defer ec.wg.Done()
				res, err := ec.resolvers.Query_customers(ec.ctx)
				if err != nil {
					ec.Error(err)
					return
				}

				arr1 := graphql.Array{}
				for idx1 := range res {
					var tmp1 graphql.Marshaler
					tmp1 = ec._customer(field.Selections, &res[idx1])
					arr1 = append(arr1, tmp1)
				}
				out.Values[i] = arr1
			}(i, field)
		case "torture":
			var arg0 [][]int
			if tmp, ok := field.Args["customerIds"]; ok {
				var err error
				rawIf1 := tmp.([]interface{})
				arg0 = make([][]int, len(rawIf1))
				for idx1 := range rawIf1 {
					rawIf2 := rawIf1[idx1].([]interface{})
					arg0[idx1] = make([]int, len(rawIf2))
					for idx2 := range rawIf2 {

						arg0[idx1][idx2], err = graphql.UnmarshalInt(rawIf2[idx2])
					}
				}
				if err != nil {
					ec.Error(err)
					return graphql.Null
				}
			}
			ec.wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				defer ec.wg.Done()
				res, err := ec.resolvers.Query_torture(ec.ctx, arg0)
				if err != nil {
					ec.Error(err)
					return
				}

				arr1 := graphql.Array{}
				for idx1 := range res {
					var tmp1 graphql.Marshaler

					arr2 := graphql.Array{}
					for idx2 := range res[idx1] {
						var tmp2 graphql.Marshaler
						tmp2 = ec._customer(field.Selections, &res[idx1][idx2])
						arr2 = append(arr2, tmp2)
					}
					tmp1 = arr2
					arr1 = append(arr1, tmp1)
				}
				out.Values[i] = arr1
			}(i, field)
		case "__schema":
			res := ec.introspectSchema()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Schema(field.Selections, res)
			}
		case "__type":
			var arg0 string
			if tmp, ok := field.Args["name"]; ok {
				var err error

				arg0, err = graphql.UnmarshalString(tmp)
				if err != nil {
					ec.Error(err)
					return graphql.Null
				}
			}
			res := ec.introspectType(arg0)

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(sel []query.Selection, it *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __DirectiveImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			res := it.Name()

			out.Values[i] = graphql.MarshalString(res)
		case "description":
			res := it.Description()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "locations":
			res := it.Locations()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler
				tmp1 = graphql.MarshalString(res[idx1])
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "args":
			res := it.Args()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___InputValue(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(sel []query.Selection, it *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __EnumValueImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			res := it.Name()

			out.Values[i] = graphql.MarshalString(res)
		case "description":
			res := it.Description()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "isDeprecated":
			res := it.IsDeprecated()

			out.Values[i] = graphql.MarshalBoolean(res)
		case "deprecationReason":
			res := it.DeprecationReason()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(sel []query.Selection, it *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __FieldImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			res := it.Name()

			out.Values[i] = graphql.MarshalString(res)
		case "description":
			res := it.Description()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "args":
			res := it.Args()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___InputValue(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "type":
			res := it.Type()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		case "isDeprecated":
			res := it.IsDeprecated()

			out.Values[i] = graphql.MarshalBoolean(res)
		case "deprecationReason":
			res := it.DeprecationReason()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(sel []query.Selection, it *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __InputValueImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			res := it.Name()

			out.Values[i] = graphql.MarshalString(res)
		case "description":
			res := it.Description()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "type":
			res := it.Type()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		case "defaultValue":
			res := it.DefaultValue()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(sel []query.Selection, it *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __SchemaImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			res := it.Types()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___Type(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "queryType":
			res := it.QueryType()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		case "mutationType":
			res := it.MutationType()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		case "subscriptionType":
			res := it.SubscriptionType()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		case "directives":
			res := it.Directives()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___Directive(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(sel []query.Selection, it *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __TypeImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias
		out.Values[i] = graphql.Null

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			res := it.Kind()

			out.Values[i] = graphql.MarshalString(res)
		case "name":
			res := it.Name()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "description":
			res := it.Description()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = graphql.MarshalString(*res)
			}
		case "fields":
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				var err error

				arg0, err = graphql.UnmarshalBoolean(tmp)
				if err != nil {
					ec.Error(err)
					return graphql.Null
				}
			}
			res := it.Fields(arg0)

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___Field(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "interfaces":
			res := it.Interfaces()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___Type(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "possibleTypes":
			res := it.PossibleTypes()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___Type(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "enumValues":
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				var err error

				arg0, err = graphql.UnmarshalBoolean(tmp)
				if err != nil {
					ec.Error(err)
					return graphql.Null
				}
			}
			res := it.EnumValues(arg0)

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___EnumValue(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "inputFields":
			res := it.InputFields()

			arr1 := graphql.Array{}
			for idx1 := range res {
				var tmp1 graphql.Marshaler

				if res[idx1] == nil {
					tmp1 = graphql.Null
				} else {
					tmp1 = ec.___InputValue(field.Selections, res[idx1])
				}
				arr1 = append(arr1, tmp1)
			}
			out.Values[i] = arr1
		case "ofType":
			res := it.OfType()

			if res == nil {
				out.Values[i] = graphql.Null
			} else {
				out.Values[i] = ec.___Type(field.Selections, res)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var parsedSchema = schema.MustParse("schema {\n    query: Query\n}\n\ntype Query {\n    customers: [Customer!]\n\n    # this method is here to test code generation of nested arrays\n    torture(customerIds: [[Int]]): [[Customer!]]\n}\n\ntype Customer {\n    id: Int!\n    name: String!\n    address: Address\n    orders: [Order!]\n}\n\ntype Address {\n    id: Int!\n    street: String!\n    country: String!\n}\n\ntype Order {\n    id: Int!\n    date: Time!\n    amount: Float!\n    items: [Item!]\n}\n\ntype Item {\n    name: String!\n}\nscalar Time\n")

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}
