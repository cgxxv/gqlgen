// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package dataloader

import (
	context "context"
	fmt "fmt"
	io "io"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	sync "sync"
	time "time"

	mapstructure "github.com/mitchellh/mapstructure"
	jsonw "github.com/vektah/gqlgen/jsonw"
	errors "github.com/vektah/gqlgen/neelance/errors"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
	validation "github.com/vektah/gqlgen/neelance/validation"
)

type Resolvers interface {
	Customer_address(ctx context.Context, it *Customer) (*Address, error)
	Customer_orders(ctx context.Context, it *Customer) ([]Order, error)

	Order_items(ctx context.Context, it *Order) ([]Item, error)

	Query_customers(ctx context.Context) ([]Customer, error)
}

func NewExecutor(resolvers Resolvers) func(context.Context, string, string, map[string]interface{}, io.Writer) []*errors.QueryError {
	return func(ctx context.Context, document string, operationName string, variables map[string]interface{}, w io.Writer) []*errors.QueryError {
		doc, qErr := query.Parse(document)
		if qErr != nil {
			return []*errors.QueryError{qErr}
		}

		errs := validation.Validate(parsedSchema, doc)
		if len(errs) != 0 {
			return errs
		}

		op, err := doc.GetOperation(operationName)
		if err != nil {
			return []*errors.QueryError{errors.Errorf("%s", err)}
		}

		c := executionContext{
			resolvers: resolvers,
			variables: variables,
			doc:       doc,
			ctx:       ctx,
		}

		var result jsonw.JsonWriter
		if op.Type == query.Query {
			result = c._query(op.Selections, nil)

		} else {
			return []*errors.QueryError{errors.Errorf("unsupported operation type")}
		}

		c.wg.Wait()

		// TODO: parallelize if query.

		writer := jsonw.New(w)
		writer.BeginObject()

		writer.ObjectKey("data")
		result.WriteJson(writer)

		if len(c.Errors) > 0 {
			writer.ObjectKey("errors")
			errors.WriteErrors(w, c.Errors)
		}

		writer.EndObject()
		return nil
	}
}

type executionContext struct {
	errors.Builder
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
	wg        sync.WaitGroup
}

var (
	addressImplementors      = []string{"Address"}
	customerImplementors     = []string{"Customer"}
	itemImplementors         = []string{"Item"}
	orderImplementors        = []string{"Order"}
	queryImplementors        = []string{"Query"}
	__DirectiveImplementors  = []string{"__Directive"}
	__EnumValueImplementors  = []string{"__EnumValue"}
	__FieldImplementors      = []string{"__Field"}
	__InputValueImplementors = []string{"__InputValue"}
	__SchemaImplementors     = []string{"__Schema"}
	__TypeImplementors       = []string{"__Type"}
)

type _AddressNode struct {
	_fields []collectedField

	Id      int
	Street  string
	Country string
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _address(sel []query.Selection, it *Address) jsonw.JsonWriter {
	node := _AddressNode{
		_fields: ec.collectFields(sel, addressImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "id":
			res := it.ID

			node.Id = res

		case "street":
			res := it.Street

			node.Street = res

		case "country":
			res := it.Country

			node.Country = res

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *_AddressNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "id":
			w.ObjectKey("id")
			w.Int(t.Id)
		case "street":
			w.ObjectKey("street")
			w.String(t.Street)
		case "country":
			w.ObjectKey("country")
			w.String(t.Country)

		}
	}
	w.EndObject()
}

type _CustomerNode struct {
	_fields []collectedField

	Id      int
	Name    string
	Address jsonw.JsonWriter
	Orders  []jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _customer(sel []query.Selection, it *Customer) jsonw.JsonWriter {
	node := _CustomerNode{
		_fields: ec.collectFields(sel, customerImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "id":
			res := it.ID

			node.Id = res

		case "name":
			res := it.Name

			node.Name = res

		case "address":

			ec.wg.Add(1)
			go func(field collectedField) {
				defer ec.wg.Done()

				res, err := ec.resolvers.Customer_address(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				if res != nil {

					node.Address = ec._address(field.Selections, res)

				}

			}(field)

		case "orders":

			ec.wg.Add(1)
			go func(field collectedField) {
				defer ec.wg.Done()

				res, err := ec.resolvers.Customer_orders(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				if res != nil {

					for i := range res {
						node.Orders = append(node.Orders, ec._order(field.Selections, &res[i]))
					}

				}

			}(field)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *_CustomerNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "id":
			w.ObjectKey("id")
			w.Int(t.Id)
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)
		case "address":
			w.ObjectKey("address")
			if t.Address == nil {
				w.Null()
			} else {
				t.Address.WriteJson(w)
			}
		case "orders":
			w.ObjectKey("orders")
			w.BeginArray()
			for _, val := range t.Orders {
				val.WriteJson(w)
			}
			w.EndArray()

		}
	}
	w.EndObject()
}

type _ItemNode struct {
	_fields []collectedField

	Name string
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _item(sel []query.Selection, it *Item) jsonw.JsonWriter {
	node := _ItemNode{
		_fields: ec.collectFields(sel, itemImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "name":
			res := it.Name

			node.Name = res

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *_ItemNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)

		}
	}
	w.EndObject()
}

type _OrderNode struct {
	_fields []collectedField

	Id     int
	Date   time.Time
	Amount float64
	Items  []jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _order(sel []query.Selection, it *Order) jsonw.JsonWriter {
	node := _OrderNode{
		_fields: ec.collectFields(sel, orderImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "id":
			res := it.ID

			node.Id = res

		case "date":
			res := it.Date

			node.Date = res

		case "amount":
			res := it.Amount

			node.Amount = res

		case "items":

			ec.wg.Add(1)
			go func(field collectedField) {
				defer ec.wg.Done()

				res, err := ec.resolvers.Order_items(ec.ctx, it)
				if err != nil {
					ec.Error(err)
					return
				}

				if res != nil {

					for i := range res {
						node.Items = append(node.Items, ec._item(field.Selections, &res[i]))
					}

				}

			}(field)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *_OrderNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "id":
			w.ObjectKey("id")
			w.Int(t.Id)
		case "date":
			w.ObjectKey("date")
			w.Time(t.Date)
		case "amount":
			w.ObjectKey("amount")
			w.Float64(t.Amount)
		case "items":
			w.ObjectKey("items")
			w.BeginArray()
			for _, val := range t.Items {
				val.WriteJson(w)
			}
			w.EndArray()

		}
	}
	w.EndObject()
}

type _QueryNode struct {
	_fields []collectedField

	Customers []jsonw.JsonWriter
	__schema  jsonw.JsonWriter
	__type    jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _query(sel []query.Selection, it *interface{}) jsonw.JsonWriter {
	node := _QueryNode{
		_fields: ec.collectFields(sel, queryImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "customers":

			ec.wg.Add(1)
			go func(field collectedField) {
				defer ec.wg.Done()

				res, err := ec.resolvers.Query_customers(ec.ctx)
				if err != nil {
					ec.Error(err)
					return
				}

				if res != nil {

					for i := range res {
						node.Customers = append(node.Customers, ec._customer(field.Selections, &res[i]))
					}

				}

			}(field)

		case "__schema":
			res := ec.introspectSchema()

			if res != nil {

				node.__schema = ec.___Schema(field.Selections, res)

			}

		case "__type":
			var arg0 string
			if tmp, ok := field.Args["name"]; ok {
				tmp2, err := coerceString(tmp)
				if err != nil {
					ec.Error(err)
					continue
				}
				arg0 = tmp2
			}
			res := ec.introspectType(arg0)

			if res != nil {

				node.__type = ec.___Type(field.Selections, res)

			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *_QueryNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "customers":
			w.ObjectKey("customers")
			w.BeginArray()
			for _, val := range t.Customers {
				val.WriteJson(w)
			}
			w.EndArray()
		case "__schema":
			w.ObjectKey("__schema")
			if t.__schema == nil {
				w.Null()
			} else {
				t.__schema.WriteJson(w)
			}
		case "__type":
			w.ObjectKey("__type")
			if t.__type == nil {
				w.Null()
			} else {
				t.__type.WriteJson(w)
			}

		}
	}
	w.EndObject()
}

type ___DirectiveNode struct {
	_fields []collectedField

	Name        string
	Description *string
	Locations   []string
	Args        []jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(sel []query.Selection, it *introspection.Directive) jsonw.JsonWriter {
	node := ___DirectiveNode{
		_fields: ec.collectFields(sel, __DirectiveImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "name":
			res := it.Name()

			node.Name = res

		case "description":
			res := it.Description()

			node.Description = res

		case "locations":
			res := it.Locations()

			node.Locations = res

		case "args":
			res := it.Args()

			if res != nil {

				for i := range res {
					node.Args = append(node.Args, ec.___InputValue(field.Selections, res[i]))
				}

			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___DirectiveNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)
		case "description":
			w.ObjectKey("description")
			if t.Description == nil {
				w.Null()
			} else {
				w.String(*t.Description)
			}
		case "locations":
			w.ObjectKey("locations")
			w.BeginArray()
			for _, val := range t.Locations {
				w.String(val)
			}
			w.EndArray()
		case "args":
			w.ObjectKey("args")
			w.BeginArray()
			for _, val := range t.Args {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()

		}
	}
	w.EndObject()
}

type ___EnumValueNode struct {
	_fields []collectedField

	Name              string
	Description       *string
	IsDeprecated      bool
	DeprecationReason *string
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(sel []query.Selection, it *introspection.EnumValue) jsonw.JsonWriter {
	node := ___EnumValueNode{
		_fields: ec.collectFields(sel, __EnumValueImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "name":
			res := it.Name()

			node.Name = res

		case "description":
			res := it.Description()

			node.Description = res

		case "isDeprecated":
			res := it.IsDeprecated()

			node.IsDeprecated = res

		case "deprecationReason":
			res := it.DeprecationReason()

			node.DeprecationReason = res

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___EnumValueNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)
		case "description":
			w.ObjectKey("description")
			if t.Description == nil {
				w.Null()
			} else {
				w.String(*t.Description)
			}
		case "isDeprecated":
			w.ObjectKey("isDeprecated")
			w.Bool(t.IsDeprecated)
		case "deprecationReason":
			w.ObjectKey("deprecationReason")
			if t.DeprecationReason == nil {
				w.Null()
			} else {
				w.String(*t.DeprecationReason)
			}

		}
	}
	w.EndObject()
}

type ___FieldNode struct {
	_fields []collectedField

	Name              string
	Description       *string
	Args              []jsonw.JsonWriter
	Type              jsonw.JsonWriter
	IsDeprecated      bool
	DeprecationReason *string
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(sel []query.Selection, it *introspection.Field) jsonw.JsonWriter {
	node := ___FieldNode{
		_fields: ec.collectFields(sel, __FieldImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "name":
			res := it.Name()

			node.Name = res

		case "description":
			res := it.Description()

			node.Description = res

		case "args":
			res := it.Args()

			if res != nil {

				for i := range res {
					node.Args = append(node.Args, ec.___InputValue(field.Selections, res[i]))
				}

			}

		case "type":
			res := it.Type()

			if res != nil {

				node.Type = ec.___Type(field.Selections, res)

			}

		case "isDeprecated":
			res := it.IsDeprecated()

			node.IsDeprecated = res

		case "deprecationReason":
			res := it.DeprecationReason()

			node.DeprecationReason = res

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___FieldNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)
		case "description":
			w.ObjectKey("description")
			if t.Description == nil {
				w.Null()
			} else {
				w.String(*t.Description)
			}
		case "args":
			w.ObjectKey("args")
			w.BeginArray()
			for _, val := range t.Args {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "type":
			w.ObjectKey("type")
			if t.Type == nil {
				w.Null()
			} else {
				t.Type.WriteJson(w)
			}
		case "isDeprecated":
			w.ObjectKey("isDeprecated")
			w.Bool(t.IsDeprecated)
		case "deprecationReason":
			w.ObjectKey("deprecationReason")
			if t.DeprecationReason == nil {
				w.Null()
			} else {
				w.String(*t.DeprecationReason)
			}

		}
	}
	w.EndObject()
}

type ___InputValueNode struct {
	_fields []collectedField

	Name         string
	Description  *string
	Type         jsonw.JsonWriter
	DefaultValue *string
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(sel []query.Selection, it *introspection.InputValue) jsonw.JsonWriter {
	node := ___InputValueNode{
		_fields: ec.collectFields(sel, __InputValueImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "name":
			res := it.Name()

			node.Name = res

		case "description":
			res := it.Description()

			node.Description = res

		case "type":
			res := it.Type()

			if res != nil {

				node.Type = ec.___Type(field.Selections, res)

			}

		case "defaultValue":
			res := it.DefaultValue()

			node.DefaultValue = res

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___InputValueNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "name":
			w.ObjectKey("name")
			w.String(t.Name)
		case "description":
			w.ObjectKey("description")
			if t.Description == nil {
				w.Null()
			} else {
				w.String(*t.Description)
			}
		case "type":
			w.ObjectKey("type")
			if t.Type == nil {
				w.Null()
			} else {
				t.Type.WriteJson(w)
			}
		case "defaultValue":
			w.ObjectKey("defaultValue")
			if t.DefaultValue == nil {
				w.Null()
			} else {
				w.String(*t.DefaultValue)
			}

		}
	}
	w.EndObject()
}

type ___SchemaNode struct {
	_fields []collectedField

	Types            []jsonw.JsonWriter
	QueryType        jsonw.JsonWriter
	MutationType     jsonw.JsonWriter
	SubscriptionType jsonw.JsonWriter
	Directives       []jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(sel []query.Selection, it *introspection.Schema) jsonw.JsonWriter {
	node := ___SchemaNode{
		_fields: ec.collectFields(sel, __SchemaImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "types":
			res := it.Types()

			if res != nil {

				for i := range res {
					node.Types = append(node.Types, ec.___Type(field.Selections, res[i]))
				}

			}

		case "queryType":
			res := it.QueryType()

			if res != nil {

				node.QueryType = ec.___Type(field.Selections, res)

			}

		case "mutationType":
			res := it.MutationType()

			if res != nil {

				node.MutationType = ec.___Type(field.Selections, res)

			}

		case "subscriptionType":
			res := it.SubscriptionType()

			if res != nil {

				node.SubscriptionType = ec.___Type(field.Selections, res)

			}

		case "directives":
			res := it.Directives()

			if res != nil {

				for i := range res {
					node.Directives = append(node.Directives, ec.___Directive(field.Selections, res[i]))
				}

			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___SchemaNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "types":
			w.ObjectKey("types")
			w.BeginArray()
			for _, val := range t.Types {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "queryType":
			w.ObjectKey("queryType")
			if t.QueryType == nil {
				w.Null()
			} else {
				t.QueryType.WriteJson(w)
			}
		case "mutationType":
			w.ObjectKey("mutationType")
			if t.MutationType == nil {
				w.Null()
			} else {
				t.MutationType.WriteJson(w)
			}
		case "subscriptionType":
			w.ObjectKey("subscriptionType")
			if t.SubscriptionType == nil {
				w.Null()
			} else {
				t.SubscriptionType.WriteJson(w)
			}
		case "directives":
			w.ObjectKey("directives")
			w.BeginArray()
			for _, val := range t.Directives {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()

		}
	}
	w.EndObject()
}

type ___TypeNode struct {
	_fields []collectedField

	Kind          string
	Name          *string
	Description   *string
	Fields        []jsonw.JsonWriter
	Interfaces    []jsonw.JsonWriter
	PossibleTypes []jsonw.JsonWriter
	EnumValues    []jsonw.JsonWriter
	InputFields   []jsonw.JsonWriter
	OfType        jsonw.JsonWriter
}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(sel []query.Selection, it *introspection.Type) jsonw.JsonWriter {
	node := ___TypeNode{
		_fields: ec.collectFields(sel, __TypeImplementors, map[string]bool{}),
	}

	for _, field := range node._fields {
		switch field.Name {
		case "kind":
			res := it.Kind()

			node.Kind = res

		case "name":
			res := it.Name()

			node.Name = res

		case "description":
			res := it.Description()

			node.Description = res

		case "fields":
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				tmp2, err := coerceBool(tmp)
				if err != nil {
					ec.Error(err)
					continue
				}
				arg0 = tmp2
			}
			res := it.Fields(arg0)

			if res != nil {

				for i := range res {
					node.Fields = append(node.Fields, ec.___Field(field.Selections, res[i]))
				}

			}

		case "interfaces":
			res := it.Interfaces()

			if res != nil {

				for i := range res {
					node.Interfaces = append(node.Interfaces, ec.___Type(field.Selections, res[i]))
				}

			}

		case "possibleTypes":
			res := it.PossibleTypes()

			if res != nil {

				for i := range res {
					node.PossibleTypes = append(node.PossibleTypes, ec.___Type(field.Selections, res[i]))
				}

			}

		case "enumValues":
			var arg0 bool
			if tmp, ok := field.Args["includeDeprecated"]; ok {
				tmp2, err := coerceBool(tmp)
				if err != nil {
					ec.Error(err)
					continue
				}
				arg0 = tmp2
			}
			res := it.EnumValues(arg0)

			if res != nil {

				for i := range res {
					node.EnumValues = append(node.EnumValues, ec.___EnumValue(field.Selections, res[i]))
				}

			}

		case "inputFields":
			res := it.InputFields()

			if res != nil {

				for i := range res {
					node.InputFields = append(node.InputFields, ec.___InputValue(field.Selections, res[i]))
				}

			}

		case "ofType":
			res := it.OfType()

			if res != nil {

				node.OfType = ec.___Type(field.Selections, res)

			}

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return &node
}

func (t *___TypeNode) WriteJson(w *jsonw.Writer) {
	w.BeginObject()
	for _, field := range t._fields {
		switch field.Name {
		case "kind":
			w.ObjectKey("kind")
			w.String(t.Kind)
		case "name":
			w.ObjectKey("name")
			if t.Name == nil {
				w.Null()
			} else {
				w.String(*t.Name)
			}
		case "description":
			w.ObjectKey("description")
			if t.Description == nil {
				w.Null()
			} else {
				w.String(*t.Description)
			}
		case "fields":
			w.ObjectKey("fields")
			w.BeginArray()
			for _, val := range t.Fields {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "interfaces":
			w.ObjectKey("interfaces")
			w.BeginArray()
			for _, val := range t.Interfaces {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "possibleTypes":
			w.ObjectKey("possibleTypes")
			w.BeginArray()
			for _, val := range t.PossibleTypes {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "enumValues":
			w.ObjectKey("enumValues")
			w.BeginArray()
			for _, val := range t.EnumValues {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "inputFields":
			w.ObjectKey("inputFields")
			w.BeginArray()
			for _, val := range t.InputFields {
				if val == nil {
					w.Null()
				} else {
					val.WriteJson(w)
				}
			}
			w.EndArray()
		case "ofType":
			w.ObjectKey("ofType")
			if t.OfType == nil {
				w.Null()
			} else {
				t.OfType.WriteJson(w)
			}

		}
	}
	w.EndObject()
}

var parsedSchema = schema.MustParse("schema {\n    query: Query\n}\n\ntype Query {\n    customers: [Customer!]\n}\n\ntype Customer {\n    id: Int!\n    name: String!\n    address: Address\n    orders: [Order!]\n}\n\ntype Address {\n    id: Int!\n    street: String\n    country: String\n}\n\ntype Order {\n    id: Int!\n    date: Time\n    amount: Float!\n    items: [Item!]\n}\n\ntype Item {\n    name: String\n}\n")

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

func instanceOf(val string, satisfies []string) bool {
	for _, s := range satisfies {
		if val == s {
			return true
		}
	}
	return false
}

func (ec *executionContext) collectFields(selSet []query.Selection, satisfies []string, visited map[string]bool) []collectedField {
	var groupedFields []collectedField

	for _, sel := range selSet {
		switch sel := sel.(type) {
		case *query.Field:
			f := getOrCreateField(&groupedFields, sel.Name.Name, func() collectedField {
				f := collectedField{
					Alias: sel.Alias.Name,
					Name:  sel.Name.Name,
				}
				if len(sel.Arguments) > 0 {
					f.Args = map[string]interface{}{}
					for _, arg := range sel.Arguments {
						f.Args[arg.Name.Name] = arg.Value.Value(ec.variables)
					}
				}
				return f
			})

			f.Selections = append(f.Selections, sel.Selections...)
		case *query.InlineFragment:
			if !instanceOf(sel.On.Ident.Name, satisfies) {
				continue
			}

			for _, childField := range ec.collectFields(sel.Selections, satisfies, visited) {
				f := getOrCreateField(&groupedFields, childField.Name, func() collectedField { return childField })
				f.Selections = append(f.Selections, childField.Selections...)
			}

		case *query.FragmentSpread:
			fragmentName := sel.Name.Name
			if _, seen := visited[fragmentName]; seen {
				continue
			}
			visited[fragmentName] = true

			fragment := ec.doc.Fragments.Get(fragmentName)
			if fragment == nil {
				ec.Errorf("missing fragment %s", fragmentName)
				continue
			}

			if !instanceOf(fragment.On.Ident.Name, satisfies) {
				continue
			}

			for _, childField := range ec.collectFields(fragment.Selections, satisfies, visited) {
				f := getOrCreateField(&groupedFields, childField.Name, func() collectedField { return childField })
				f.Selections = append(f.Selections, childField.Selections...)
			}

		default:
			panic(fmt.Errorf("unsupported %T", sel))
		}
	}

	return groupedFields
}

type collectedField struct {
	Alias      string
	Name       string
	Args       map[string]interface{}
	Selections []query.Selection
}

func decodeHook(sourceType reflect.Type, destType reflect.Type, value interface{}) (interface{}, error) {
	if destType.PkgPath() == "time" && destType.Name() == "Time" {
		if dateStr, ok := value.(string); ok {
			return time.Parse(time.RFC3339, dateStr)
		}
		return nil, errors.Errorf("time should be an RFC3339 formatted string")
	}
	return value, nil
}

// nolint: deadcode, megacheck
func unpackComplexArg(result interface{}, data interface{}) error {
	decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		TagName:     "graphql",
		ErrorUnused: true,
		Result:      result,
		DecodeHook:  decodeHook,
	})
	if err != nil {
		panic(err)
	}

	return decoder.Decode(data)
}

func getOrCreateField(c *[]collectedField, name string, creator func() collectedField) *collectedField {
	for i, cf := range *c {
		if cf.Alias == name {
			return &(*c)[i]
		}
	}

	f := creator()

	*c = append(*c, f)
	return &(*c)[len(*c)-1]
}

// nolint: deadcode, megacheck
func coerceString(v interface{}) (string, error) {
	switch v := v.(type) {
	case string:
		return v, nil
	case int:
		return strconv.Itoa(v), nil
	case float64:
		return fmt.Sprintf("%f", v), nil
	case bool:
		if v {
			return "true", nil
		} else {
			return "false", nil
		}
	case nil:
		return "null", nil
	default:
		return "", fmt.Errorf("%T is not a string", v)
	}
}

// nolint: deadcode, megacheck
func coerceBool(v interface{}) (bool, error) {
	switch v := v.(type) {
	case string:
		return "true" == strings.ToLower(v), nil
	case int:
		return v != 0, nil
	case bool:
		return v, nil
	default:
		return false, fmt.Errorf("%T is not a bool", v)
	}
}

// nolint: deadcode, megacheck
func coerceInt(v interface{}) (int, error) {
	switch v := v.(type) {
	case string:
		return strconv.Atoi(v)
	case int:
		return v, nil
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("%T is not an int", v)
	}
}

// nolint: deadcode, megacheck
func coercefloat64(v interface{}) (float64, error) {
	switch v := v.(type) {
	case string:
		return strconv.ParseFloat(v, 64)
	case int:
		return float64(v), nil
	case float64:
		return v, nil
	default:
		return 0, fmt.Errorf("%T is not an float", v)
	}
}
