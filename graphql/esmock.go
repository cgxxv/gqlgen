// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package graphql

import (
	"context"
	"github.com/vektah/gqlparser/ast"
	"sync"
)

var (
	lockExecutableSchemaMockComplexity   sync.RWMutex
	lockExecutableSchemaMockMutation     sync.RWMutex
	lockExecutableSchemaMockQuery        sync.RWMutex
	lockExecutableSchemaMockSchema       sync.RWMutex
	lockExecutableSchemaMockSubscription sync.RWMutex
)

// Ensure, that ExecutableSchemaMock does implement ExecutableSchema.
// If this is not the case, regenerate this file with moq.
var _ ExecutableSchema = &ExecutableSchemaMock{}

// ExecutableSchemaMock is a mock implementation of ExecutableSchema.
//
//     func TestSomethingThatUsesExecutableSchema(t *testing.T) {
//
//         // make and configure a mocked ExecutableSchema
//         mockedExecutableSchema := &ExecutableSchemaMock{
//             ComplexityFunc: func(typeName string, fieldName string, childComplexity int, args map[string]interface{}) (int, bool) {
// 	               panic("mock out the Complexity method")
//             },
//             MutationFunc: func(ctx context.Context, op *ast.OperationDefinition) *Response {
// 	               panic("mock out the Mutation method")
//             },
//             QueryFunc: func(ctx context.Context, op *ast.OperationDefinition) *Response {
// 	               panic("mock out the Query method")
//             },
//             SchemaFunc: func() *ast.Schema {
// 	               panic("mock out the Schema method")
//             },
//             SubscriptionFunc: func(ctx context.Context, op *ast.OperationDefinition) func() *Response {
// 	               panic("mock out the Subscription method")
//             },
//         }
//
//         // use mockedExecutableSchema in code that requires ExecutableSchema
//         // and then make assertions.
//
//     }
type ExecutableSchemaMock struct {
	// ComplexityFunc mocks the Complexity method.
	ComplexityFunc func(typeName string, fieldName string, childComplexity int, args map[string]interface{}) (int, bool)

	// MutationFunc mocks the Mutation method.
	MutationFunc func(ctx context.Context, op *ast.OperationDefinition) *Response

	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, op *ast.OperationDefinition) *Response

	// SchemaFunc mocks the Schema method.
	SchemaFunc func() *ast.Schema

	// SubscriptionFunc mocks the Subscription method.
	SubscriptionFunc func(ctx context.Context, op *ast.OperationDefinition) func() *Response

	// calls tracks calls to the methods.
	calls struct {
		// Complexity holds details about calls to the Complexity method.
		Complexity []struct {
			// TypeName is the typeName argument value.
			TypeName string
			// FieldName is the fieldName argument value.
			FieldName string
			// ChildComplexity is the childComplexity argument value.
			ChildComplexity int
			// Args is the args argument value.
			Args map[string]interface{}
		}
		// Mutation holds details about calls to the Mutation method.
		Mutation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op *ast.OperationDefinition
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op *ast.OperationDefinition
		}
		// Schema holds details about calls to the Schema method.
		Schema []struct {
		}
		// Subscription holds details about calls to the Subscription method.
		Subscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op *ast.OperationDefinition
		}
	}
}

// Complexity calls ComplexityFunc.
func (mock *ExecutableSchemaMock) Complexity(typeName string, fieldName string, childComplexity int, args map[string]interface{}) (int, bool) {
	if mock.ComplexityFunc == nil {
		panic("ExecutableSchemaMock.ComplexityFunc: method is nil but ExecutableSchema.Complexity was just called")
	}
	callInfo := struct {
		TypeName        string
		FieldName       string
		ChildComplexity int
		Args            map[string]interface{}
	}{
		TypeName:        typeName,
		FieldName:       fieldName,
		ChildComplexity: childComplexity,
		Args:            args,
	}
	lockExecutableSchemaMockComplexity.Lock()
	mock.calls.Complexity = append(mock.calls.Complexity, callInfo)
	lockExecutableSchemaMockComplexity.Unlock()
	return mock.ComplexityFunc(typeName, fieldName, childComplexity, args)
}

// ComplexityCalls gets all the calls that were made to Complexity.
// Check the length with:
//     len(mockedExecutableSchema.ComplexityCalls())
func (mock *ExecutableSchemaMock) ComplexityCalls() []struct {
	TypeName        string
	FieldName       string
	ChildComplexity int
	Args            map[string]interface{}
} {
	var calls []struct {
		TypeName        string
		FieldName       string
		ChildComplexity int
		Args            map[string]interface{}
	}
	lockExecutableSchemaMockComplexity.RLock()
	calls = mock.calls.Complexity
	lockExecutableSchemaMockComplexity.RUnlock()
	return calls
}

// Mutation calls MutationFunc.
func (mock *ExecutableSchemaMock) Mutation(ctx context.Context, op *ast.OperationDefinition) *Response {
	if mock.MutationFunc == nil {
		panic("ExecutableSchemaMock.MutationFunc: method is nil but ExecutableSchema.Mutation was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}{
		Ctx: ctx,
		Op:  op,
	}
	lockExecutableSchemaMockMutation.Lock()
	mock.calls.Mutation = append(mock.calls.Mutation, callInfo)
	lockExecutableSchemaMockMutation.Unlock()
	return mock.MutationFunc(ctx, op)
}

// MutationCalls gets all the calls that were made to Mutation.
// Check the length with:
//     len(mockedExecutableSchema.MutationCalls())
func (mock *ExecutableSchemaMock) MutationCalls() []struct {
	Ctx context.Context
	Op  *ast.OperationDefinition
} {
	var calls []struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}
	lockExecutableSchemaMockMutation.RLock()
	calls = mock.calls.Mutation
	lockExecutableSchemaMockMutation.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *ExecutableSchemaMock) Query(ctx context.Context, op *ast.OperationDefinition) *Response {
	if mock.QueryFunc == nil {
		panic("ExecutableSchemaMock.QueryFunc: method is nil but ExecutableSchema.Query was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}{
		Ctx: ctx,
		Op:  op,
	}
	lockExecutableSchemaMockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	lockExecutableSchemaMockQuery.Unlock()
	return mock.QueryFunc(ctx, op)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//     len(mockedExecutableSchema.QueryCalls())
func (mock *ExecutableSchemaMock) QueryCalls() []struct {
	Ctx context.Context
	Op  *ast.OperationDefinition
} {
	var calls []struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}
	lockExecutableSchemaMockQuery.RLock()
	calls = mock.calls.Query
	lockExecutableSchemaMockQuery.RUnlock()
	return calls
}

// Schema calls SchemaFunc.
func (mock *ExecutableSchemaMock) Schema() *ast.Schema {
	if mock.SchemaFunc == nil {
		panic("ExecutableSchemaMock.SchemaFunc: method is nil but ExecutableSchema.Schema was just called")
	}
	callInfo := struct {
	}{}
	lockExecutableSchemaMockSchema.Lock()
	mock.calls.Schema = append(mock.calls.Schema, callInfo)
	lockExecutableSchemaMockSchema.Unlock()
	return mock.SchemaFunc()
}

// SchemaCalls gets all the calls that were made to Schema.
// Check the length with:
//     len(mockedExecutableSchema.SchemaCalls())
func (mock *ExecutableSchemaMock) SchemaCalls() []struct {
} {
	var calls []struct {
	}
	lockExecutableSchemaMockSchema.RLock()
	calls = mock.calls.Schema
	lockExecutableSchemaMockSchema.RUnlock()
	return calls
}

// Subscription calls SubscriptionFunc.
func (mock *ExecutableSchemaMock) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *Response {
	if mock.SubscriptionFunc == nil {
		panic("ExecutableSchemaMock.SubscriptionFunc: method is nil but ExecutableSchema.Subscription was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}{
		Ctx: ctx,
		Op:  op,
	}
	lockExecutableSchemaMockSubscription.Lock()
	mock.calls.Subscription = append(mock.calls.Subscription, callInfo)
	lockExecutableSchemaMockSubscription.Unlock()
	return mock.SubscriptionFunc(ctx, op)
}

// SubscriptionCalls gets all the calls that were made to Subscription.
// Check the length with:
//     len(mockedExecutableSchema.SubscriptionCalls())
func (mock *ExecutableSchemaMock) SubscriptionCalls() []struct {
	Ctx context.Context
	Op  *ast.OperationDefinition
} {
	var calls []struct {
		Ctx context.Context
		Op  *ast.OperationDefinition
	}
	lockExecutableSchemaMockSubscription.RLock()
	calls = mock.calls.Subscription
	lockExecutableSchemaMockSubscription.RUnlock()
	return calls
}
