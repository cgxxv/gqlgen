package templates

const fileTpl = `
{{define "file" }}
// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package {{ .PackageName }}

import (
{{- range $import := .Imports }}
	{{- $import.Write }}
{{ end }}
)

type Resolvers interface {
{{- range $object := .Objects -}}
	{{ range $field := $object.Fields -}}
		{{ $field.ResolverDeclaration }}
	{{ end }}
{{- end }}
}

func NewExecutor(resolvers Resolvers) func(context.Context, string, string, map[string]interface{}, io.Writer) []*errors.QueryError {
	return func(ctx context.Context, document string, operationName string, variables map[string]interface{}, w io.Writer) []*errors.QueryError {
		doc, qErr := query.Parse(document)
		if qErr != nil {
			return []*errors.QueryError{qErr}
		}

		errs := validation.Validate(parsedSchema, doc)
		if len(errs) != 0 {
			return errs
		}

		op, err := doc.GetOperation(operationName)
		if err != nil {
			return []*errors.QueryError{errors.Errorf("%s", err)}
		}

		c := executionContext{
			resolvers: resolvers,
			variables: variables,
			doc:       doc,
			ctx:       ctx,
		}

		var data graphql.Marshaler
		if op.Type == query.Query {
			data = c._{{.QueryRoot.GQLType|lcFirst}}(op.Selections, nil)
		{{- if .MutationRoot}}
		} else if op.Type == query.Mutation {
			data = c._{{.MutationRoot.GQLType|lcFirst}}(op.Selections, nil)
		{{- end}}{{ if .SubscriptionRoot}}
		} else if op.Type == query.Subscription {
			data = c._{{.SubscriptionRoot.GQLType|lcFirst}}(op.Selections, nil)
		{{- end}}
		} else {
			return []*errors.QueryError{errors.Errorf("unsupported operation type")}
		}

		c.wg.Wait()

		result := &graphql.OrderedMap{}
		result.Add("data", data)

		if len(c.Errors) > 0 {
			result.Add("errors", graphql.MarshalErrors(c.Errors))
		}

		result.MarshalGQL(w)
		return nil
	}
}

type executionContext struct {
	errors.Builder
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
	wg        sync.WaitGroup
}

{{- range $object := .Objects }}
	{{ template "object" $object }}
{{- end}}

{{- range $interface := .Interfaces }}
	{{ template "interface" $interface }}
{{- end }}

{{- range $input := .Inputs }}
	{{ template "input" $input }}
{{- end }}

var parsedSchema = schema.MustParse({{.SchemaRaw|quote}})

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

{{end}}
`
